练习：https://github.com/Dream-Life/front-end/tree/master/function

# 函数式编程
1. 学习函数式编程的理由
    - react和vue3.0都使用函数式编程
    - 函数式编程可以抛弃this
    - 打包时可以更好的利用tree-shaking过滤无用的代码
    - 方便测试和并行处理
    - 有许多第三方库帮助我们进行函数式开发，如lodash，underscore, ramda

2. 高阶函数的意义
    - 抽象通用问题
    - 代码更加简洁

3. 闭包：
    - 函数和其周围的状态（词法环境）的引用捆绑在一起形成闭包
    - 可以在另一个作用域中调用一个函数的内部函数并访问到该函数作用域的成员
  
     闭包的本质：函数执行时会放到执行栈中，执行完毕后就从执行栈移除，但堆上的作用域成员即变量因为被外部引用即返回function中被引用，所以不能被释放，因此内部函数即返回的function依然可以访问外部函数的成员

4. 纯函数：相同的输入，输出相同，即不改变原数组
    ```javascript
    const arr = [1,2,3,5,7,8,6]
    cosnt {log}=console
    // 输出都一样，为纯函数
    log(arr.slice(0,3))
    log(arr.slice(0,3))
    // 输出不一样，为不纯函数
    log(arr.splice(0,1))
    log(arr.splice(0,1))
    ```

5. lodash纯函数的使用
6. 纯函数的好处：
    - 可缓存，将结果缓存起来(lodash.memoize)
    - 可以并行处理
    - 可测试
7. web worker可以开启js的多线程
8. 函数柯里化：当一个函数有多个参数时，可以先传递一部分参数，然后返回一个新函数接受剩余参数，返回结果
   ```javascript
    const checkAge = min => (age=>age>=min)
    cosnt {log}=console
    let checkAge18 = checkAge(18)
    let checkAge20 = checkAge(20)
    
    checkAge18(24) // false
    checkAge18(15) // true
    checkAge20(20) // true
    checkAge20(24) // false
    ```
    ```javascript
    // lodash柯里化
    const _ = require('lodash')
    const {log}= console

    function getSum(a,b,c){
        return a+b+c
    }

    const curried = _.curry(getSum)

    log(curried(1,2,3))
    log(curried(1)(2,3))
    log(curried(1,2)(3))
    ```

9. 柯里化的优点
    - 给一个函数传递较少的参数得到一个已经记住了某些固定参数的新函数
    - 这是一种对函数参数的缓存
    - 让函数更加灵活，粒度更小
    - 可以把多元函数转换成一元函数，可以使用函数组合
10. 函数组合: 一个函数经过多个函数（数据管道）得到最终值，可以将中间的函数合并成一个函数。

    注意：合并的函数为纯函数
     ```javascript
     // lodash.flowRight() 实现函数组合
     const _ = require('lodash')
    const {log}= console

    const reverse = arr=>arr.reverse()
    const first = arr=>arr[0]
    const toUpper = s=>s.toUpperCase()

    const f = _.flowRight(toUpper,first,reverse)
    log(f(['sss','ddd','ewew']))
     ```
11. 函数组合-结合律
12. 函数组合-调试
      ```javascript
    // 调试
    const _ = require('lodash')
    const {log}= console
    const trace = _.curry((msg,v)=>{
        log(`${msg}: ${v}`)
        return v
    })
    const m = _.flowRight(_.toUpper,trace('first'),_.first,trace('reverse'),_.reverse)
    ```
13. lodash/fp模块
    - lodash和lodash/fp模块map有区别;区别在于lodash.map(arr,(value,index,arr)=>{}),fp.map((value)=>{},arr)

14. point free：合成函数,函数组合
15. Functor（函子）
    - 为了将副作用控制在可控范围内
    - 函子：是一种特殊的容器（函数），通过一个普通的对象来实现，该对象有map方法，map方法可以运行一个函数对值进行处理（变形关系）
    ```javascript
    // Functor
    // 封装_value值，防止副作用
    // _value就是副作用的外部变量
    // class作为一个盒子
    class Container{
        static of(v){
            return new Container(v)
        }
        constructor(v){
            this._value = v
        }
        // 通过map返回一个纯函数，用来处理_value(盒子内部的值)
        map(fn){
            return Container.of(fn(this._value))
        }
    }

    let r =  Container.of(5)
            .map(x=>x+2)
            .map(x=>x*x)
    console.log(r)   
    ```
16. 函数副作用：让一个函数变成不纯函数，函数内依赖外部变量（状态），会导致输入相同时，外部变量变化时，输出不相同的副作用
17. maybe函子为了解决函子传入null引发的副作用（Container.of(null)）
18. Either函子：两者中的任何一个，类似if...else...的处理；也可以用来处理异常
19. IO函子
20. Folktale和task异步执行
    ```javascript
    const fs = require('fs')
    const {task} = require('folktale/concurrency/task')
    const {split, find} = require('lodash/fp')
    const {log} = console

    function readFile(filename){
        return task(resolver=>{
            fs.readFile(filename, 'utf-8', (err,data)=>{
                if(err) resolver.reject(err)
                resolver.resolve(data)
            })
        })
    }

    // task是一个函子
    readFile('package.json')
        .map(split('\n'))
        .map(find(x=>x.includes('version')))
        .run()
        .listen({
            onRejected:err=>log(err),
            onResolved: value=>log(value)
        })
    ```

21. Pointed 函子就是有static of(){}的函子
22. Monad函子同时具有join和of两个方法并遵守一些定律
23. Functor, Pointed MayBe, Either, IO, Task,Monad
    - Functor函子就是带有map方法的class
    - Pointed 函子就是有static of(){}的函子
    - MayBe函子多了一个对null和undefined的判断。用于解决传值为空的问题
    - Either函子多了对的和错的两种函子，正确的使用对的函子，报错用错的函子。用于解决异常报错问题
    - Task函子是folktale的task。用于异步执行
    - IO函子this._value=fn；new IO(function(){return value})。可以延迟执行一个函数，控制副作用
    - Monad函子同时具有join和of两个方法并遵守一些定律;join()返回this._value();也可以说带有join方法的IO函子。用于解决函子嵌套问题


# javascript性能优化
1. js内存管理
2. js的垃圾回收机制